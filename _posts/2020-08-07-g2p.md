---
layout: post
title:  "Getting from 'a' to 'b' with g2p"
author: aidan
categories: []
tags: [ tutorial, explanation, tech-showcase ]
image: assets/images/bonjour-g2p.png
description: "How to get from 'a' to 'b' using the g2p library"
featured: false
hidden: true
---

This blog post describes the background context for a software tool called `g2p` which is shorthand for 'Grapheme-to-Phoneme', but if you don't know those terms, don't worry, this post will explain it. Essentially, `g2p` is a tool for converting between two types of text, whether you want to convert between a [writing system and the phonetic alphabet](#use-case-1-getting-the-pronunciation-from-a-words-spelling), between two [writing systems for the same language](use-case-2-a-language-with-multiple-writing-systems), or between a legacy ['font-hacked' writing system and its current Unicode-supported version](use-case-3-converting-from-legacy-writing-systems).

# What you need to know to understand this post

- To understand the advanced section, you will need to know some [Python](https://www.python.org/)

# Who is involved with this project?

- Maintainer (i.e. the person to bug with questions): [Aidan Pine](aidanpine.ca)
- Lots of [other contributors](https://github.com/roedoejet/g2p/graphs/contributors)

# What are the motivations behind G2P?

There are many reasons why you might want to systematically convert between different characters[^1]. Here are a few possible use cases:

### Use Case #1: Getting the pronunciation from a word's spelling

Sometimes you want to convert between a language's writing system (also known as *orthography*) and its pronunciation. "Letters" in a writing system are usually referred to as "graphemes" and their corresponding meaningful sounds are referred to as "phonemes"; hence "g2p" or "grapheme-to-phoneme". 

It gets a little more complicated than that though, because sometimes a grapheme is made of more than one character, as in "th" which can be pronounced *[unvoiced](https://www.thoughtco.com/voiced-and-voiceless-consonants-1212092#:~:text=Voiceless%20consonants%20do%20not%20use,as%20in%20%22thing%22).)* as in 'thin' or *[voiced](https://www.thoughtco.com/voiced-and-voiceless-consonants-1212092#:~:text=Voiced%20Consonants,-Your%20vocal%20cords&text=As%20you%20pronounce%20a%20letter,W%2C%20Y%2C%20and%20Z.)* as in 'that'. 

The [International Phonetic Alphabet](https://en.wikipedia.org/wiki/International_Phonetic_Alphabet) is not so ambiguous, and writes the 'th' in 'thin' as **θ** and the 'th' in 'that' as **ð**. Knowing how to convert between the written and spoken form of a language is useful in a variety of computational tasks, but I will describe the usefulness specifically with a project called "ReadAlongs" [below](#readalongs).

### Use Case #2: A language with multiple writing systems

Some languages have two (or more!) different writing systems. Take Cree for example, where you can either write a word in *Standard Roman Orthography* like "ê-wêpâpîhkêwêpinamâhk" or in *Syllabics* like **ᐁᐍᐹᐲᐦᑫᐍᐱᐊᒫᕽ**. My colleague [Eddie](https:://eddieanotonio.ca) has a great blog post about a tool he created to convert between the two [here]({{ "why-a-new-cree-syllabics-converter" | absolute_url }}).

### Use Case #3: Converting from legacy writing systems

Some languages historically used 'font hacks' to render the characters in their writing system before they were supported standardly on computers. There's a longer discussion to be had here, but the coles' notes version is that when computers were gaining popularity, they weren't typically able to *render* (ie display) characters outside of the 128 characters supported by the [American Standard Code for Information Interchange (ASCII)](https://en.wikipedia.org/wiki/ASCII). To get around this, language communities would come up with their own custom fonts (often referred to as 'font hacks' or 'font encodings') where they would render characters like '©' which existed in ASCII as 'ǧ' instead (example taken from the Heiltsuk Doulos font). For more information on this topic, please check out ['Seeing the Heiltsuk Orthography from Font Encoding through to Unicode'](http://aidanpine.ca/static/cv/pdfs/Pine-Turin-Convertextract-2018.pdf) or ['Applications and innovations in typeface design for North American Indigenous languages'](https://markturin.sites.olt.ubc.ca/files/2020/06/Schillo_Turin_typeface_2020.pdf).

# How to get from 'a' to 'b' (or 'a' to 'æ') with g2p

`g2p` is a Python library[^2] that helps you convert between different characters based on user-defined rules. The inspiration for how to write these rules was mostly taken from the notion of [phonological rewrite rules](https://en.wikipedia.org/wiki/Phonological_rule), which is a common way of capturing 'multi-level' phonological changes. What is meant by that is the idea that a word, like 'cats' or 'dogs' can have multiple 'levels' of representation. For example, you might think of the way that those words are written in English orthography (writing system) as one level. Then, you might think of a general pronunciation for those words, written in the phonetic alphabet, as another level. You could also separate that level into more than one level by having a level each for [narrow and broad transcriptions](https://en.wikipedia.org/wiki/Phonetic_transcription#Narrow_versus_broad_transcription:~:text=orthography.-,Narrow%20versus%20broad%20transcription).

| Level Name |  Word #1   |  Word #2  | Word # 3 |
|---|---|---|---|
| Level 1 (orthography) | cat | dog | back |
| Level 2 (broad IPA) | kæt | dɑɡ | bæk |
| Level 3 (narrow IPA) | kʰæt | dɑɡ | bæk |

Now, just by looking at these three levels, you can probably see some fairly systematic rules here that you could imagine would get you from one level to the next, even if you don't know the phonetic alphabet by-heart and even if you don't really know about the English phonology (sound patterns and systems).

First of all, it looks like all of the 'a' characters in level one turn to 'æ', so we might want a rule to express that all instances of 'a' turn to /æ/. And, for another example, it looks like between levels 2 and 3, /k/ turns into either [k] or [kʰ] depending on whether it occurs before or after /æ/[^3]. So, with these hypotheses about the rules to transform from one level to another, how do we start translating this into rules for `g2p`?

## Basic Rule writing

`g2p` lets you describe these patterns using an ordered list of rules. Each rule must be defined to have an sequence of one or more input characters and a sequence of zero or more output characters. We can define these rules in `g2p` either using a tabular, spreadsheet format (csv) or using a format called JavaScript Object Notation or [JSON](https://www.json.org/json-en.html). To actually write these rules along with this blog post, I recommend getting some sort of text editor, like [Visual Studio Code](https://code.visualstudio.com/). You can also write the spreadsheet-type rules in your favourite spreadsheet editor.

| in | out |
|---|---|
| a | æ |

or using [JSON](https://www.json.org/json-en.html):

```json
[
    {
        "in": "a",
        "out": "æ"
    }
]
```

Both of the above rules capture our first, rule that turns an orthographic 'a' into a broad IPA /æ/. You can choose to write your rules in **either** format.

If we want to write rules that depend on a particular context, we need a couple more columns (csv) or keys (JSON) than just `in` and `out`. This is where we use `context_before` and `context_after`. So, our second rule from above was to turn /k/ to [kʰ] when the character after /k/ is /æ/. Here, we could write the rules like this:

| in | out | context_before | context_after |
|---|---|---|---|
| k | kʰ | | æ |

or like this using JSON:

```json
[
    {
        "in": "k",
        "out": "kʰ",
        "context_after": "æ"
    }
]
```

## Ok, so how do I actually get started here?

So, you've understood the [basics of writing rules](#basic-rule-writing) either described above and you want to actually use them to convert something! This section describes exactly how to do that. The easiest way to write rules quickly is using the [G2P Studio](https://g2p-studio.herokuapp.com/) web application[^4].

Once landing on the G2P Studio page, you can scroll down to the [Custom Rules](https://g2p-studio.herokuapp.com/#out_delimiter-0:~:text=Custom%20Rules) section and start directly editing the spreadsheet available there. Below is a list of all the rules to capture the transformations between level 1 and level 2 above. There are some rules that we discussed in that section, and some others that might look unfamiliar. For a full description of some of these rules, have a look at the [advanced mapping section](#a-deeper-dive-into-writing-tricky-rules).

{% picture assets/images/custom-rules-g2p-studio.png %}

Then, you can write some text in the left text-area at the top of the G2P Studio, and g2p will apply your rules and produce the output in the right text area as seen below:

{% picture assets/images/custom-rules-output-g2p-studio.png %}

You can then click on 'Export' under the Custom Rules section to export your rules to a CSV file if you want to save them for later.

## Mapping configuration

When you combine multiple rules in `g2p` for a particular purpose, this is called a *mapping*. In addition to each file containing your rules, you need a configuration file that tells `g2p` how to process your rules. We write mapping configurations in files titled `config.yaml`. You will need some sort of text editor, like [VS Code](https://code.visualstudio.com/) in order to edit your configuration file. 

### Special settings

...more to come...

## Advanced: A deeper dive into writing tricky rules

You may have noticed that the rules described above for converting words like 'dog' and 'cat' to IPA are woefully incomplete. The real world use cases for `g2p` often need to account for a lot more messiness than was described in the artificial example above. In fact, for languages like English, `g2p` is likely **not** a good solution. The English writing system is notoriously inconsistent, and there already exist a variety of other tools that account for all of the lexical (word-specific) idiosyncracies in deriving the IPA-form from the orthographic form. For many Indigenous languages, the writing system is sufficiently close to the spoken form that `g2p` is a very appropriate solution. In the following sections, I'll describe some common problems when writing rules, and how to fix them.

### Unicode Escape Sequences

Sometimes you need rules to convert from characters that either don't render very well, or render in a confusing way. In those cases, you can alternatively use [Unicode escape sequences](https://www.rapidtables.com/code/text/unicode-characters.html). For example, maybe you want to write a rule that converts the standard ASCII 'g' to the strict IPA Unicode /ɡ/. As you can likely see on your browser, these characters look very similar, but they're not! The ASCII 'g' is U+0067 and the strict IPA 'ɡ' is U+0261. So, you can write a rule as follows:


| in | out |
|---|---|
| \u0067 | \u0261 |

or using [JSON](https://www.json.org/json-en.html):

```json
[
    {
        "in": "\u0067",
        "out": "\u0261"
    }
]
```

This is also helpful when you need to write rules between combining characters or other confusable characters. The **rule of thumb** is, if your rules are clearer using Unicode escape sequences, do it! Otherwise, just use the normal character in place.

### Rule Ordering

The order of your rules in `g2p` really matters! This is because some rules can either create or remove the context for other rules to apply. In linguistic, these rule ordering patterns are usually talked about as either [feeding, bleeding, counter-feeding, or counter-bleeding](https://linguistics.stackexchange.com/questions/6084/whats-the-difference-between-counterbleeding-bleeding-and-feeding) relationships. There are valid reasons to want to encode any of these types of relationships in your rules. 

To illustrate a possible problem, let's consider a `g2p` mapping for language that converts 'a̱' to 'ə' and 'a' to 'æ'. 'a̱' is a sequence of a normal a followed by a combining macron below (\u0331). Because \u0331 ('a̱') is easily confusable with \u0332 ('a̲'), in order to follow the rule of thumb for [Unicode escape sequences](#unicode-escape-sequences), I'll write the rules as follows:

| in | out |
|---|---|
| a | æ |
| a\u0331 | ə |

Now, assuming an input to this mapping of 'a̱' (a\u0331), we would get 'æ̱' (æ\u0331) instead of 'ə'. Why is that? Because the first rule applies and turns 'a' into 'æ' before the second rule has a chance to apply. This is called a 'bleeding' relationship. In order to avoid it, we would need to write our rules as follows:

| in | out |
|---|---|
| a\u0331 | ə |
| a | æ |

With this ordering, our input of 'a̱' (a\u0331) would turn into 'ə' as we expect, and our input of 'a' would turn into æ also as expected. Try it out on the [G2P Studio](https://g2p-studio.herokuapp.com) if you don't believe me!

### Defining sets of characters

...more to come...

### Regular Expressions

...more to come...

### Using specific indices

...more to come...

## Applications

There are number of different software tools that are already making use of `g2p`. For general purpose use in Python, have a look at [this section](#advanced-use-in-python). G2P is also used extensively in the [ReadAlongs](#readalongs) project for creating interactive audio/text documents and in [Convertextract](#convertextract), a tool for going `g2p` transformations in Microsoft Office documents while preserving the original document formatting.

### ReadAlongs

...more to come...

### Convertextract
[Convertextract]({{ "convertextract-app" | absolute_url }})

### Advanced: use in Python

...more to come...

## Advanced: contributing your rules to the main `g2p` library

You've written some cool rules and you want to contribute, that's awesome! 

...more to come...

### Footnotes

[^1]: Because the word 'letter' usually refers to a character within a specific alphabet or writing system, instead of 'letter', I'm going to use the word 'character' throughout this post.
[^2]: A Python 'library' is a collection of code
[^3]: Orthographic characters are circumfixed with apostrophes like 'a', broad IPA typically uses forward slashes like /k/ and narrow IPA typically uses square brackets like [kʰ]
[^4]: I'm using the free, hobby plan at <https://www.heroku.com/> to host it though, so occasionally the server goes to sleep. If you first go to the site and it takes a few seconds to boot up, don't worry!